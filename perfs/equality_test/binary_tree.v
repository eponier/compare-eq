Require Import Recdef.
Require Import Lia.

Inductive tree : Type :=
| Leaf : tree
| Node : nat -> tree -> tree -> tree.

Fixpoint binary_tree c n :=
  match n with
  | 0 => Leaf
  | S n =>
    let t := binary_tree c n in
    Node c t t
  end.

Definition t0 := Eval vm_compute in binary_tree 0 20.
Definition t1 := Eval vm_compute in binary_tree 1 20.

From elpi.apps Require Import feqb.
From elpi.apps Require Import derive.

(* Register Inline andb. (* -> andb becomes lazy *) *)

Module feqb.

feqb nat.
feqb tree.

End feqb.

Module Elpi.

#[only(eqOK),verbose] derive nat.
#[only(eqOK),verbose] derive tree.

End Elpi.

From Equations Require Import Equations.

Derive NoConfusion EqDec for tree.

Scheme Equality for tree.

Definition dec_eq : forall (x y : tree), {x=y} + {x<>y}.
Proof. decide equality. decide equality. Defined.

From mathcomp Require Import ssreflect ssrnat eqtype.
From deriving Require Import deriving.

Module Import D.

(* t_rect is the recursor automatically generated by Coq *)
Time Definition tree_indDef := [indDef for tree_rect].
Canonical tree_indType := IndType tree tree_indDef.

Module nored.

(* see https://github.com/arthuraa/deriving#simplification-and-performance-issues *)
Definition tree_eqMixin : Equality.mixin_of tree.
Proof. Time exact [derive nored eqMixin for tree]. Time Defined. (* -> Memory overflow if we use this with QED *)

Canonical tree_eqType := EqType tree tree_eqMixin.

End nored.

Module red.

Time Definition tree_eqMixin := [derive eqMixin for tree].
Canonical tree_eqType := EqType tree tree_eqMixin.

End red.

End D.

(* Time Eval cbv in tree_eqb t_1024 t_1024. *)
(* Time Eval compute in tree_eqb t_1024 t_1024. *)  
(* Time Eval native_compute in tree_eqb t_1024 t_1024. *)

(* we run them twice, since there is some caching; only the second times must
   be taken into account
*)
Time Eval vm_compute in feqb.tree_eqb t0 t0.
Time Eval vm_compute in feqb.tree_eqb t0 t1.
Time Eval vm_compute in feqb.tree_eqb t0 t0. (* 1,24 s *)
Time Eval vm_compute in feqb.tree_eqb t0 t1. (* 1,25 s *)

Time Eval vm_compute in Elpi.tree_eq t0 t0. (* 0,15 s *)
Time Eval vm_compute in Elpi.tree_eq t0 t1. (* 0,16 s *)

(* Time Eval vm_compute in tree_eqdec t_1024 t_1024'. -> Memory overflow *)

Module D1.

Import nored.

Time Eval vm_compute in t0 == t0. (* 26 s *)
Time Eval vm_compute in t0 == t1. (* 26 s *)

End D1.

Module D2.

Import red.

Time Eval vm_compute in t0 == t0. (* 0,24 s *)
Time Eval vm_compute in t0 == t1. (* 0,29 s *)

End D2.

Time Eval vm_compute in dec_eq t0 t0. (* 1,21 s *)
Time Eval vm_compute in dec_eq t0 t1. (* 0,09 s *)
Time Eval vm_compute in tree_beq t0 t0. (* 0,17 s *)
Time Eval vm_compute in tree_beq t0 t1. (* 0,15 s*) 

(* Extraction? *)
